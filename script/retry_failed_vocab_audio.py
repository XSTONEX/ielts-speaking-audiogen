#!/usr/bin/env python3
"""
‰∏ÄÊ¨°ÊÄßËÑöÊú¨ÔºöÈáçÊñ∞ÁîüÊàêÂ§±Ë¥•ÁöÑËØçÊ±áÈü≥È¢ë‰ªªÂä°
ÂäüËÉΩÔºö
  - ÈáçÊñ∞ÁîüÊàêÂ§±Ë¥•ÁöÑÈü≥È¢ë‰ªªÂä°
  - Ëá™Âä®Ê£ÄÊµãË∂ÖÊó∂ÁöÑprocessing‰ªªÂä°ÔºàË∂ÖËøá30ÂàÜÈíüÔºâÔºåÂ∞ÜÂÖ∂Ê†áËÆ∞‰∏∫Â§±Ë¥•ÂêéÈáçÊñ∞Â§ÑÁêÜ
Áî®Ê≥ïÔºö
  python3 retry_failed_vocab_audio.py              # ÈªòËÆ§ÈáçÁΩÆÊ®°ÂºèÔºöÈáçÁΩÆÂπ∂ÈáçÊñ∞ÁîüÊàêÊâÄÊúâÂ§±Ë¥•‰ªªÂä°
  python3 retry_failed_vocab_audio.py --no-reset  # ‰∏çÈáçÁΩÆÔºöÂè™Â§ÑÁêÜÂΩìÂâçÂ§±Ë¥•ÁöÑ‰ªªÂä°
"""

import os
import json
import time
import sys
import requests
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Âä†ËΩΩÁéØÂ¢ÉÂèòÈáè
load_dotenv()

# ÁõÆÂΩïÈÖçÁΩÆ
VOCABULARY_BOOK_DIR = 'vocabulary_book'
VOCABULARY_TASKS_DIR = os.path.join(VOCABULARY_BOOK_DIR, 'tasks')
VOCABULARY_CATEGORIES_DIR = os.path.join(VOCABULARY_BOOK_DIR, 'categories')
VOCABULARY_AUDIO_DIR = os.path.join(VOCABULARY_BOOK_DIR, 'audio')

def load_category_data(category):
    """Âä†ËΩΩÂàÜÁ±ªÊï∞ÊçÆ"""
    category_file = os.path.join(VOCABULARY_CATEGORIES_DIR, f'{category}.json')
    if os.path.exists(category_file):
        with open(category_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    return None

def save_category_data(category, data):
    """‰øùÂ≠òÂàÜÁ±ªÊï∞ÊçÆ"""
    category_file = os.path.join(VOCABULARY_CATEGORIES_DIR, f'{category}.json')
    with open(category_file, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def generate_word_audio(word, word_id, category):
    """‰∏∫ÂçïËØçÁîüÊàêÈü≥È¢ëÊñá‰ª∂"""
    try:
        # Ëé∑ÂèñAPIÂØÜÈí•
        api_key = os.getenv('DEER_API_KEY')
        if not api_key:
            print("‚ùå Êú™ÊâæÂà∞DEER_API_KEYÁéØÂ¢ÉÂèòÈáè")
            return False

        # Á°Æ‰øùÈü≥È¢ëÁõÆÂΩïÂ≠òÂú®
        category_audio_dir = os.path.join(VOCABULARY_AUDIO_DIR, category)
        os.makedirs(category_audio_dir, exist_ok=True)

        # Ê£ÄÊü•Èü≥È¢ëÊòØÂê¶Â∑≤Â≠òÂú®
        audio_path = os.path.join(category_audio_dir, f"{word_id}.mp3")
        if os.path.exists(audio_path):
            print(f"‚úÖ Èü≥È¢ëÊñá‰ª∂Â∑≤Â≠òÂú®: {word}")
            return True

        print(f"üéµ Ê≠£Âú®ÁîüÊàêÈü≥È¢ë: {word}")

        # Ë∞ÉÁî®TTS API
        url = "https://api.deerapi.com/v1/audio/speech"
        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": "tts-1",
            "input": word,
            "voice": "nova",
            "response_format": "mp3"
        }

        response = requests.post(url, headers=headers, json=data, timeout=60)

        if response.status_code == 200:
            # ‰øùÂ≠òÈü≥È¢ëÊñá‰ª∂
            with open(audio_path, 'wb') as f:
                f.write(response.content)
            print(f"‚úÖ Èü≥È¢ëÁîüÊàêÊàêÂäü: {word}")
            return True
        else:
            print(f"‚ùå APIË∞ÉÁî®Â§±Ë¥• ({response.status_code}): {word}")
            return False

    except Exception as e:
        print(f"‚ùå ÁîüÊàêÈü≥È¢ëÊó∂Âá∫Èîô: {word} - {e}")
        return False

def update_task_status(task_file, status, error_msg=None):
    """Êõ¥Êñ∞‰ªªÂä°Áä∂ÊÄÅ"""
    try:
        with open(task_file, 'r', encoding='utf-8') as f:
            task = json.load(f)

        task['status'] = status
        task['last_updated'] = datetime.now().isoformat()

        if error_msg:
            task['error'] = error_msg
            task['attempts'] = task.get('attempts', 0) + 1
        elif status == 'completed':
            task['attempts'] = task.get('attempts', 0) + 1

        with open(task_file, 'w', encoding='utf-8') as f:
            json.dump(task, f, ensure_ascii=False, indent=2)

    except Exception as e:
        print(f"‚ùå Êõ¥Êñ∞‰ªªÂä°Áä∂ÊÄÅÂ§±Ë¥•: {e}")

def update_category_word_status(category, subcategory_id, word_id, audio_generated):
    """Êõ¥Êñ∞ÂàÜÁ±ª‰∏≠ÂçïËØçÁöÑÈü≥È¢ëÁîüÊàêÁä∂ÊÄÅ"""
    try:
        category_data = load_category_data(category)
        if not category_data:
            return False

        if subcategory_id in category_data['subcategories']:
            for word in category_data['subcategories'][subcategory_id]['words']:
                if word['id'] == word_id:
                    word['audio_generated'] = audio_generated
                    save_category_data(category, category_data)
                    return True

        return False
    except Exception as e:
        print(f"‚ùå Êõ¥Êñ∞ÂàÜÁ±ªÁä∂ÊÄÅÂ§±Ë¥•: {e}")
        return False

def is_task_timeout(task):
    """Ê£ÄÊü•‰ªªÂä°ÊòØÂê¶Ë∂ÖÊó∂ÔºàprocessingÁä∂ÊÄÅË∂ÖËøá30ÂàÜÈíüÔºâ"""
    if task.get('status') != 'processing':
        return False

    created_at_str = task.get('created_at')
    if not created_at_str:
        return False

    try:
        # Ëß£ÊûêÂàõÂª∫Êó∂Èó¥
        created_at = datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))
        # ËÆ°ÁÆóÊó∂Èó¥Â∑Æ
        time_diff = datetime.now() - created_at
        # Ê£ÄÊü•ÊòØÂê¶Ë∂ÖËøá30ÂàÜÈíü
        return time_diff > timedelta(minutes=30)
    except Exception as e:
        print(f"‚ö†Ô∏è Ëß£ÊûêÂàõÂª∫Êó∂Èó¥Â§±Ë¥•: {created_at_str} - {e}")
        return False

def mark_processing_task_as_failed(task_file):
    """Â∞ÜË∂ÖÊó∂ÁöÑprocessing‰ªªÂä°Ê†áËÆ∞‰∏∫failed"""
    try:
        with open(task_file, 'r', encoding='utf-8') as f:
            task = json.load(f)

        task['status'] = 'failed'
        task['error'] = '‰ªªÂä°Â§ÑÁêÜË∂ÖÊó∂ÔºàË∂ÖËøá30ÂàÜÈíüÔºâ'
        task['last_updated'] = datetime.now().isoformat()
        task['attempts'] = task.get('attempts', 0) + 1

        with open(task_file, 'w', encoding='utf-8') as f:
            json.dump(task, f, ensure_ascii=False, indent=2)

        return task.get('word', 'unknown')
    except Exception as e:
        print(f"‚ùå Ê†áËÆ∞‰ªªÂä°Â§±Ë¥•Â§±Ë¥•: {e}")
        return None

def reset_failed_tasks():
    """ÈáçÁΩÆÊâÄÊúâÂ§±Ë¥•‰ªªÂä°ÁöÑÈáçËØïËÆ°Êï∞"""
    print("üîÑ ÈáçÁΩÆÂ§±Ë¥•‰ªªÂä°ÁöÑÈáçËØïËÆ°Êï∞...")
    reset_count = 0

    if not os.path.exists(VOCABULARY_TASKS_DIR):
        print(f"‚ùå ‰ªªÂä°ÁõÆÂΩï‰∏çÂ≠òÂú®: {VOCABULARY_TASKS_DIR}")
        return 0

    for filename in os.listdir(VOCABULARY_TASKS_DIR):
        if filename.endswith('.json'):
            task_file = os.path.join(VOCABULARY_TASKS_DIR, filename)

            try:
                with open(task_file, 'r', encoding='utf-8') as f:
                    task = json.load(f)

                if task.get('status') == 'failed':
                    task['attempts'] = 0
                    task['last_updated'] = datetime.now().isoformat()

                    with open(task_file, 'w', encoding='utf-8') as f:
                        json.dump(task, f, ensure_ascii=False, indent=2)

                    reset_count += 1
                    print(f"üîÑ ÈáçÁΩÆ‰ªªÂä°: {task.get('word', 'unknown')}")

            except Exception as e:
                print(f"‚ùå Â§ÑÁêÜ‰ªªÂä°Êñá‰ª∂Â§±Ë¥• {filename}: {e}")

    print(f"‚úÖ Â∑≤ÈáçÁΩÆ {reset_count} ‰∏™Â§±Ë¥•‰ªªÂä°ÁöÑÈáçËØïËÆ°Êï∞")
    return reset_count

def main():
    # Â§ÑÁêÜÂëΩ‰ª§Ë°åÂèÇÊï∞
    reset_mode = True  # ÈªòËÆ§ÈáçÁΩÆÊ®°Âºè
    if len(sys.argv) > 1 and sys.argv[1] == '--no-reset':
        reset_mode = False

    if reset_mode:
        print("üîÑ ÈªòËÆ§ÈáçÁΩÆÊ®°ÂºèÔºöÈáçÁΩÆÂ§±Ë¥•‰ªªÂä°ÁöÑÈáçËØïËÆ°Êï∞ÂêéÈáçÊñ∞ÁîüÊàê")
        print("="*60)
        reset_failed_tasks()
        print()
    else:
        print("üîÑ ÈùûÈáçÁΩÆÊ®°ÂºèÔºöÂè™Â§ÑÁêÜÂΩìÂâçÂ§±Ë¥•ÁöÑ‰ªªÂä°...")
        print("="*60)

    # ÁªüËÆ°‰ø°ÊÅØ
    total_failed_tasks = 0
    timeout_tasks_marked = 0
    successful_regenerations = 0
    failed_regenerations = 0
    skipped_tasks = 0

    # Ê£ÄÊü•‰ªªÂä°ÁõÆÂΩïÊòØÂê¶Â≠òÂú®
    if not os.path.exists(VOCABULARY_TASKS_DIR):
        print(f"‚ùå ‰ªªÂä°ÁõÆÂΩï‰∏çÂ≠òÂú®: {VOCABULARY_TASKS_DIR}")
        return

    # Êâ´ÊèèÊâÄÊúâ‰ªªÂä°Êñá‰ª∂
    task_files = []
    for filename in os.listdir(VOCABULARY_TASKS_DIR):
        if filename.endswith('.json'):
            task_files.append(filename)

    if not task_files:
        print("‚ÑπÔ∏è Ê≤°ÊúâÊâæÂà∞‰ªª‰Ωï‰ªªÂä°Êñá‰ª∂")
        return

    print(f"üìã ÂèëÁé∞ {len(task_files)} ‰∏™‰ªªÂä°Êñá‰ª∂")

    # Â§ÑÁêÜÊØè‰∏™‰ªªÂä°Êñá‰ª∂
    for filename in task_files:
        task_file = os.path.join(VOCABULARY_TASKS_DIR, filename)

        try:
            # ËØªÂèñ‰ªªÂä°Êï∞ÊçÆ
            with open(task_file, 'r', encoding='utf-8') as f:
                task = json.load(f)

            # Ê£ÄÊü•‰ªªÂä°Áä∂ÊÄÅ
            task_status = task.get('status', 'unknown')
            word = task.get('word', 'unknown')

            # Ê£ÄÊü•ÊòØÂê¶ÊòØË∂ÖÊó∂ÁöÑprocessing‰ªªÂä°
            if task_status == 'processing' and is_task_timeout(task):
                print(f"‚è∞ ÂèëÁé∞Ë∂ÖÊó∂‰ªªÂä°ÔºåÂ∞ÜÊ†áËÆ∞‰∏∫Â§±Ë¥•: {word} (ID: {task.get('id', 'unknown')})")
                marked_word = mark_processing_task_as_failed(task_file)
                if marked_word:
                    task_status = 'failed'  # Êõ¥Êñ∞Áä∂ÊÄÅ‰ª•‰æøÁªßÁª≠Â§ÑÁêÜ
                    timeout_tasks_marked += 1
                    print(f"‚úÖ Â∑≤Â∞ÜË∂ÖÊó∂‰ªªÂä°Ê†áËÆ∞‰∏∫Â§±Ë¥•: {marked_word}")
                else:
                    print(f"‚ùå Ê†áËÆ∞Ë∂ÖÊó∂‰ªªÂä°Â§±Ë¥•Â§±Ë¥•: {word}")
                    skipped_tasks += 1
                    continue

            # Âè™Â§ÑÁêÜÂ§±Ë¥•ÁöÑ‰ªªÂä°
            if task_status != 'failed':
                print(f"‚è≠Ô∏è Ë∑≥ËøáÈùûÂ§±Ë¥•‰ªªÂä°: {word} ({task_status})")
                skipped_tasks += 1
                continue

            total_failed_tasks += 1
            word = task.get('word', '')
            word_id = task.get('word_id', '')
            category = task.get('category', '')
            subcategory_id = task.get('subcategory_id', '')

            print(f"\nüîÑ Â§ÑÁêÜÂ§±Ë¥•‰ªªÂä°: {word} (ID: {word_id})")

            # Ê£ÄÊü•ÈáçËØïÊ¨°Êï∞
            attempts = task.get('attempts', 0)
            max_attempts = task.get('max_attempts', 3)

            if attempts >= max_attempts:
                print(f"‚ö†Ô∏è ‰ªªÂä°Â∑≤ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞ ({max_attempts})ÔºåË∑≥Ëøá")
                skipped_tasks += 1
                continue

            # ÁîüÊàêÈü≥È¢ë
            success = generate_word_audio(word, word_id, category)

            if success:
                # Êõ¥Êñ∞‰ªªÂä°Áä∂ÊÄÅ‰∏∫ÂÆåÊàê
                update_task_status(task_file, 'completed')

                # Êõ¥Êñ∞ÂàÜÁ±ª‰∏≠ÁöÑÂçïËØçÁä∂ÊÄÅ
                update_category_word_status(category, subcategory_id, word_id, True)

                # Âà†Èô§ÊàêÂäüÂÆåÊàêÁöÑ‰ªªÂä°Êñá‰ª∂
                try:
                    os.remove(task_file)
                    print(f"üóëÔ∏è  Âà†Èô§ÂÆåÊàê‰ªªÂä°Êñá‰ª∂: {word}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Âà†Èô§‰ªªÂä°Êñá‰ª∂Â§±Ë¥•: {word} - {e}")

                successful_regenerations += 1
                print(f"‚úÖ ‰ªªÂä°ÈáçÊñ∞ÁîüÊàêÊàêÂäü: {word}")
            else:
                # Êõ¥Êñ∞‰ªªÂä°Áä∂ÊÄÅ‰∏∫Â§±Ë¥•ÔºàÂ¢ûÂä†ÈáçËØïÊ¨°Êï∞Ôºâ
                update_task_status(task_file, 'failed', 'Èü≥È¢ëÁîüÊàêAPIË∞ÉÁî®Â§±Ë¥•')

                failed_regenerations += 1
                print(f"‚ùå ‰ªªÂä°ÈáçÊñ∞ÁîüÊàêÂ§±Ë¥•: {word}")

            # ÈÅøÂÖçAPIÈ¢ëÁéáÈôêÂà∂
            time.sleep(0.5)

        except Exception as e:
            print(f"‚ùå Â§ÑÁêÜ‰ªªÂä°Êñá‰ª∂Â§±Ë¥• {filename}: {e}")
            failed_regenerations += 1
            continue

    # ËæìÂá∫ÁªüËÆ°ÁªìÊûú
    print("\n" + "="*60)
    print("üìä ÈáçÊñ∞ÁîüÊàêÁªüËÆ°Êä•Âëä")
    print("="*60)
    print(f"üìÅ ÊÄª‰ªªÂä°Êñá‰ª∂Êï∞: {len(task_files)}")
    print(f"‚è∞ Ê†áËÆ∞Ë∂ÖÊó∂‰ªªÂä°Êï∞: {timeout_tasks_marked}")
    print(f"‚ùå Â§±Ë¥•‰ªªÂä°Êï∞: {total_failed_tasks}")
    print(f"‚è≠Ô∏è  Ë∑≥Ëøá‰ªªÂä°Êï∞: {skipped_tasks}")
    print(f"‚úÖ ÈáçÊñ∞ÁîüÊàêÊàêÂäü: {successful_regenerations}")
    print(f"‚ùå ÈáçÊñ∞ÁîüÊàêÂ§±Ë¥•: {failed_regenerations}")
    print(f"‚úÖ ÊàêÂäüÁéá: {(successful_regenerations / max(1, successful_regenerations + failed_regenerations)) * 100:.1f}%")
    if failed_regenerations > 0:
        print("‚ö†Ô∏è  ÈÉ®ÂàÜ‰ªªÂä°ÈáçÊñ∞ÁîüÊàêÂ§±Ë¥•ÔºåÂèØËÉΩÈúÄË¶ÅÊ£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñAPIÂØÜÈí•")
        print("   ÂèØ‰ª•Á®çÂêéÈáçÊñ∞ËøêË°åÊ≠§ËÑöÊú¨Êù•ÈáçËØïÂ§±Ë¥•ÁöÑ‰ªªÂä°")

    print("="*60)

if __name__ == "__main__":
    main()
